

# 🤖 K近邻算法（KNN）入门实战：一步步看懂分类原理

> *“KNN 是最简单的机器学习算法之一，但背后藏着直觉的力量。”*

---

## 🧠 什么是 K 近邻算法（K-Nearest Neighbors）？

**K 近邻算法（KNN）** 是一种基本的、易于理解的**监督学习算法**，用于**分类**或**回归**问题。

其核心思想是：

> **“看一个点属于哪个类别，就看它周围最近的 K 个点，谁多就投谁。”**

就像你搬进一个新社区，如果你身边大多数邻居是程序员，那你也可能是程序员。

---

## 📦 示例代码实战

我们通过一个非常简洁的代码片段来理解 KNN 的运行机制。

```python
from sklearn.neighbors import KNeighborsClassifier

# 特征数据（二维数组，每个样本只有一个特征）
x = [[0], [1], [2], [3]]
# 标签数据（每个样本的类别）
y = [0, 0, 1, 1]

# 实例化模型，设置 k=1（即最近一个邻居）
estimator = KNeighborsClassifier(n_neighbors=1)

# 拟合模型（训练过程）
estimator.fit(x, y)
```

这段代码的含义如下：

| 项目              | 含义                      |
| --------------- | ----------------------- |
| `x`             | 表示特征向量：4 个点，每个点只有一个数值特征 |
| `y`             | 表示每个点的标签，0 或 1，代表不同类别   |
| `n_neighbors=1` | 意味着我们只看离目标点最近的一个训练点     |

---

## 🔍 预测分析

接下来我们用这个模型来进行预测：

```python
estimator.predict([[1]])
# 输出：array([0])
```

### ✅ 分析：

* 输入 `[1]` 正好是训练集中一个点，对应标签是 `0`，因此预测为 `0`。

---

```python
estimator.predict([[0.5]])
# 输出：array([0])
```

### ✅ 分析：

* `0.5` 离 `0` 的距离是 `0.5`
* 离 `1` 的距离也是 `0.5`
* 都一样近，但我们设置了 `k=1`，scikit-learn 默认按顺序选最近的一个，取 `0` 对应的标签。

---

```python
estimator.predict([[1.5]])
# 输出：array([0])
```

### ✅ 分析：

* 离 1 的距离是 `0.5`
* 离 2 的距离也是 `0.5`
* 最近的仍是 `[1]`（因为排序后先到它），所以预测为 `[1]` 对应的标签：`0`

---

```python
estimator.predict([[1.6]])
# 输出：array([1])
```

### ✅ 分析：

* 离 `[2]` 的距离是 `0.4`
* 离 `[1]` 的距离是 `0.6`
* 更靠近 `[2]`，其标签为 `1`，所以预测结果为 `1`

---

## 📊 KNN 的核心机制解析

### 📍 特征空间与距离度量

KNN 的核心是：

> **在特征空间中找到最近的 K 个点，用它们的标签来投票。**

常用的距离度量：

* 欧几里得距离（默认）
* 曼哈顿距离
* 闵可夫斯基距离

### 🧮 举例说明欧几里得距离：

$$
\text{距离}(a, b) = \sqrt{(a - b)^2}
$$

比如：

* `dist(1.6, 2) = 0.4`
* `dist(1.6, 1) = 0.6`

所以 1.6 更靠近 2。

---

## 🎯 K 的选取对结果的影响

| K 值  | 特征          |
| ---- | ----------- |
| K=1  | 灵敏、但容易受噪声影响 |
| K 较大 | 平滑、但可能过度泛化  |

通常会使用交叉验证等方式选择一个合适的 K 值。

---

## 🔚 总结：KNN 是这样工作的

✔️ KNN 不需要训练模型，**训练过程就是记住数据**
✔️ 预测时直接计算距离，找最近的邻居来“投票”
✔️ 适合数据量不大、维度较低的情况
✔️ 是很多其他复杂算法的启蒙基础

---

## 📎 拓展学习建议：

* 尝试在二维平面上用图像画出训练点与测试点的分布
* 尝试将 `n_neighbors` 改为 3 或 5，观察预测结果变化
* 试试 `weights='distance'` 参数，改为距离加权投票

---

## 📁 附录：完整代码

```python
from sklearn.neighbors import KNeighborsClassifier

x = [[0], [1], [2], [3]]
y = [0, 0, 1, 1]

estimator = KNeighborsClassifier(n_neighbors=1)
estimator.fit(x, y)

print(estimator.predict([[1]]))     # array([0])
print(estimator.predict([[0.5]]))   # array([0])
print(estimator.predict([[1.5]]))   # array([0])
print(estimator.predict([[1.6]]))   # array([1])
```
